(window.webpackJsonp=window.webpackJsonp||[]).push([[6],{210:function(t,a,r){"use strict";r.r(a);var e=r(28),s=Object(e.a)({},(function(){var t=this,a=t.$createElement,r=t._self._c||a;return r("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[r("h3",{attrs:{id:"dart-面试题"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#dart-面试题"}},[t._v("#")]),t._v(" Dart 面试题")]),t._v(" "),r("h4",{attrs:{id:"_1、dart-属于是强类型语言-，但可以用-var-来声明变量，dart-会自推导出数据类型，var-实际上是编译期的-语法糖-。dynamic-表示动态类型，-被编译后，实际是一个-object-类型，在编译期间不进行任何的类型检查，而是在运行期进行类型检查。"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_1、dart-属于是强类型语言-，但可以用-var-来声明变量，dart-会自推导出数据类型，var-实际上是编译期的-语法糖-。dynamic-表示动态类型，-被编译后，实际是一个-object-类型，在编译期间不进行任何的类型检查，而是在运行期进行类型检查。"}},[t._v("#")]),t._v(" 1、Dart 属于是强类型语言 ，但可以用 var 来声明变量，Dart 会自推导出数据类型，var 实际上是编译期的“语法糖”。dynamic 表示动态类型， 被编译后，实际是一个 object 类型，在编译期间不进行任何的类型检查，而是在运行期进行类型检查。")]),t._v(" "),r("h4",{attrs:{id:"_2、dart-中-if-等语句只支持-bool-类型，switch-支持-string-类型。"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_2、dart-中-if-等语句只支持-bool-类型，switch-支持-string-类型。"}},[t._v("#")]),t._v(" 2、Dart 中 if 等语句只支持 bool 类型，switch 支持 String 类型。")]),t._v(" "),r("h4",{attrs:{id:"_3、dart-中数组和-list-是一样的。"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_3、dart-中数组和-list-是一样的。"}},[t._v("#")]),t._v(" 3、Dart 中数组和 List 是一样的。")]),t._v(" "),r("h4",{attrs:{id:"_4、dart-中，runes-代表符号文字-是-utf-32-编码的字符串-用于如-runes-input-new-runes-u-1f596-u-1f44d"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_4、dart-中，runes-代表符号文字-是-utf-32-编码的字符串-用于如-runes-input-new-runes-u-1f596-u-1f44d"}},[t._v("#")]),t._v(" 4、Dart 中，Runes 代表符号文字 , 是 UTF-32 编码的字符串, 用于如 Runes input = new Runes(’\\u{1f596} \\u{1f44d}’);")]),t._v(" "),r("h4",{attrs:{id:"_5、dart-支持闭包。"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_5、dart-支持闭包。"}},[t._v("#")]),t._v(" 5、Dart 支持闭包。")]),t._v(" "),r("h4",{attrs:{id:"_6、dart-中-number-类型分为-int-和-double-，没有-float-类型。"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_6、dart-中-number-类型分为-int-和-double-，没有-float-类型。"}},[t._v("#")]),t._v(" 6、Dart 中 number 类型分为 int 和 double ，没有 float 类型。")]),t._v(" "),r("h4",{attrs:{id:"_7、dart-中-级联操作符-可以方便配置逻辑，如下代码："}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_7、dart-中-级联操作符-可以方便配置逻辑，如下代码："}},[t._v("#")]),t._v(" 7、Dart 中 级联操作符 可以方便配置逻辑，如下代码：")]),t._v(" "),r("p",[t._v('event\n..id = 1\n..type = ""\n..actor = "";')]),t._v(" "),r("h4",{attrs:{id:"_8、赋值操作符"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_8、赋值操作符"}},[t._v("#")]),t._v(" 8、赋值操作符")]),t._v(" "),r("p",[t._v('比较有意思的赋值操作符有：\nAA ?? "999"  ///表示如果 AA 为空，返回999\nAA ??= "999" ///表示如果 AA 为空，给 AA 设置成 999\nAA ~/999 ///AA 对于 999 整除')]),t._v(" "),r("h4",{attrs:{id:"_9、可选方法参数"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_9、可选方法参数"}},[t._v("#")]),t._v(" 9、可选方法参数")]),t._v(" "),r("p",[t._v("Dart 方法可以设置 参数默认值 和 指定名称")]),t._v(" "),r("p",[t._v('比如： getDetail(Sting userName, reposName, {branch = “master”}){} 方法，这里 branch 不设置的话，默认是 “master” 。参数类型 可以指定或者不指定。调用效果： getRepositoryDetailDao(“aaa", “bbbb”, branch: “dev”); 。')]),t._v(" "),r("h4",{attrs:{id:"_10、作用域"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_10、作用域"}},[t._v("#")]),t._v(" 10、作用域")]),t._v(" "),r("p",[t._v("Dart 没有关键词 public 、private 等修饰符，_ 下横向直接代表 private ，但是有 @protected 注解")]),t._v(" "),r("h4",{attrs:{id:"_11、构造方法"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_11、构造方法"}},[t._v("#")]),t._v(" 11、构造方法")]),t._v(" "),r("p",[t._v("Dart 中的多构造方法，可以通过命名方法实现。\n默认构造方法只能有一个，而通过 Model.empty() 方法可以创建一个空参数的类，其实方法名称随你喜欢，而变量初始化值时，只需要通过 this.name 在构造方法中指定即可：")]),t._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[t._v("class ModelA {\n  String name;\n  String tag;\n\n  //默认构造方法，赋值给name和tag\n  ModelA(this.name, this.tag);\n\n  //返回一个空的ModelA\n  ModelA.empty();\n\n  //返回一个设置了name的ModelA\n  ModelA.forName(this.name);\n}\n")])])]),r("h4",{attrs:{id:"_12、getter-setter-重写"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_12、getter-setter-重写"}},[t._v("#")]),t._v(" 12、getter setter 重写")]),t._v(" "),r("p",[t._v("Dart 中所有的基础类型、类等都继承 Object ，默认值是 NULL， 自带 getter 和 setter ，而如果是 final 或者 const 的话，那么它只有一个 getter 方法，Object 都支持 getter、setter 重写：")]),t._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[t._v("  @override\n  Size get preferredSize {\n    return Size.fromHeight(kTabHeight + indicatorWeight);\n  }\n")])])]),r("h4",{attrs:{id:"_13、assert-断言"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_13、assert-断言"}},[t._v("#")]),t._v(" 13、Assert(断言)")]),t._v(" "),r("p",[t._v("assert 只在检查模式有效，在开发过程中，assert(unicorn == null); 只有条件为真才正常，否则直接抛出异常，一般用在开发过程中，某些地方不应该出现什么状态的判断。")]),t._v(" "),r("h4",{attrs:{id:"_14、重写运算符，如下所示重载-operator-后对类进行-操作。"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_14、重写运算符，如下所示重载-operator-后对类进行-操作。"}},[t._v("#")]),t._v(" 14、重写运算符，如下所示重载 operator 后对类进行 +/- 操作。")]),t._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[t._v("class Vector {\n  final int x, y;\n\n  Vector(this.x, this.y);\n\n  Vector operator +(Vector v) => Vector(x + v.x, y + v.y);\n  Vector operator -(Vector v) => Vector(x - v.x, y - v.y);\n\n  ···\n}\n\nvoid main() {\n  final v = Vector(2, 3);\n  final w = Vector(2, 2);\n\n  assert(v + w == Vector(4, 5));\n  assert(v - w == Vector(0, 1));\n}\n")])])]),r("p",[t._v("类、接口、继承\nDart 中没有接口，类都可以作为接口，把某个类当做接口实现时，只需要使用 implements ，然后复写父类方法即可。\nDart 中支持 mixins ，按照出现顺序应该为extends 、 mixins 、implements 。")])])}),[],!1,null,null,null);a.default=s.exports}}]);