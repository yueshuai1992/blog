(window.webpackJsonp=window.webpackJsonp||[]).push([[21],{205:function(t,n,a){"use strict";a.r(n);var e=a(28),s=Object(e.a)({},(function(){var t=this.$createElement,n=this._self._c||t;return n("ContentSlotsDistributor",{attrs:{"slot-key":this.$parent.slotKey}},[n("h3",{attrs:{id:"js-策略模式"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#js-策略模式"}},[this._v("#")]),this._v(" JS 策略模式")]),this._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[this._v("<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n\t<meta charset=\"UTF-8\">\n\t<title>策略模式</title>\n</head>\n<body>\n\t<script>\n\t// 定义：定义一系列的算法，把它们一个个封装起来，并且使它们可以相互替换。\n\t\t// 一组策略类封装具体的算法\n\t\t/*说明：\n策略模式指的是 定义一系列的算法，把它们一个个封装起来，将不变的部分和变化的部分隔开，\n实际就是将算法的使用和实现分离出来；算法的使用方式是不变的，都是根据某个算法取得计算后的奖金数，\n而算法的实现是根据绩效对应不同的绩效规则；\n一个基于策略模式的程序至少由2部分组成，第一个部分是一组策略类，策略类封装了具体的算法，\n并负责具体的计算过程。第二个部分是环境类Context，该Context接收客户端的请求，\n随后把请求委托给某一个策略类。\n复合开放-封闭原则，可变的部分为策略类（一组算法），不变的部分为执行具体算法的方式。*/\n\t\tconst Bouns = {\n\t\t\tA (salary){\n\t\t\t\treturn salary * 4;\n\t\t\t},\n\t\t\tB (salary){\n\t\t\t\treturn salary * 3;\n\t\t\t},\n\t\t\tC (salary){\n\t\t\t\treturn salary * 2;\n\t\t\t}\n\t\t};\n\t\tObject.freeze(Bouns);\n\t\t/*\n\t\t* 计算年终奖 环境类Context\n\t\t* @param {String} A 效绩等级\n\t\t* @param {Number} 10000 每月工资\n\t\t* @returns {Number} 40000 年终奖\n\t\t*/\n\t\tconst calculateBouns = function (type, salary){\n\t\t\treturn Bouns[type](salary);\n\t\t};\n\t\t// 测试年终奖计算方式\n\t\tconst demo1 = calculateBouns('A', 10000);\n\t\tconst demo2 = calculateBouns('B', 80000);\n\t\tconsole.log(demo1, demo2); // 40000, 240000\n\t<\/script>\n</body>\n</html>\n")])])])])}),[],!1,null,null,null);n.default=s.exports}}]);