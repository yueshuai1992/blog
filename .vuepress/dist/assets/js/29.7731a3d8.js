(window.webpackJsonp=window.webpackJsonp||[]).push([[29],{231:function(e,t,n){"use strict";n.r(t);var o=n(28),a=Object(o.a)({},(function(){var e=this,t=e.$createElement,n=e._self._c||t;return n("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[n("h3",{attrs:{id:"weex-原生组件开发"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#weex-原生组件开发"}},[e._v("#")]),e._v(" WEEX 原生组件开发")]),e._v(" "),n("h4",{attrs:{id:"主要有三种方式：module方式，componont方式（hander），adapter方式"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#主要有三种方式：module方式，componont方式（hander），adapter方式"}},[e._v("#")]),e._v(" 主要有三种方式：module方式，componont方式（hander），adapter方式")]),e._v(" "),n("h4",{attrs:{id:"module调用方式"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#module调用方式"}},[e._v("#")]),e._v(" Module调用方式")]),e._v(" "),n("blockquote",[n("p",[e._v("Module 扩展必须继承 WXModule 类。")])]),e._v(" "),n("p",[e._v("扩展方法必须加上 @WXModuleAnno 注解或者@JSMethod注解。需要在vue中使用回调获得数据是使用后者。Weex 会根据注解来判断当前方法是否要运行在 UI 线程，和当前方法是否是扩展方法。\nuiThread = false  设置false为可以return  true  callback无return\nweex是根据反射来进行调用 Module 扩展方法，所以Module中的扩展方法必须是 public 类型。")]),e._v(" "),n("p",[e._v('Module扩展的方法可以使用 int, double, float, String, Map, List 类型的参数。\n完成Module 后一定要在初始化时注册 WXSDKEngine.registerModule("myModule", MyModule.class);')]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("eg:  \ni.传参数例子\n@JSMethod(uiThread = true)\n  public void printLog(String msg) {\n    String responseStr = getMD5(msg);\n    Toast.makeText(mWXSDKInstance.getContext(),responseStr,Toast.LENGTH_SHORT).show();\n  }\nii.传参数回调例子\n@JSMethod(uiThread = true)\n  public void responseMD5(String msg, JSCallback callback) {\n    String responseStr = getMD5(msg);\n    callback.invokeAndKeepAlive(responseStr);\n  }\n")])])]),n("p",[e._v("在vue通过var module=weex.requirModule（‘moduleName’）获得对象可以调用其方法")]),e._v(" "),n("h4",{attrs:{id:"component调用方式"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#component调用方式"}},[e._v("#")]),e._v(" Component调用方式")]),e._v(" "),n("blockquote",[n("p",[e._v("Component 扩展类必须继承 WXComponent.")])]),e._v(" "),n("p",[e._v('对应的设置属性的方法必须添加注解 @WXComponentProp(name=value)\nWeex sdk通过反射调用对应的方法，所以 Component 对应的属性方法必须是 public。\n扩展的方法可以使用 int, double, float, String, Map, List 类型的参数\n完成Component 后一定要在初始化时注册 WXSDKEngine.registerComponent("richtext",RichText.class);')]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v('eg:  \npublic class WXCardView extends WXComponent<TextView> {\n    private TextView view;\n    public WXCardView(WXSDKInstance instance, WXDomObject dom, WXVContainer parent){\n        super(instance, dom, parent);\n    }\n    @Override\n    protected TextView initComponentHostView(@NonNull Context context) {\n        view = new TextView(context);\n        view.setMovementMethod(LinkMovementMethod.getInstance());\n        view.setBackgroundColor(context.getResources().getColor(R.color.black_overlay));\n        view.setTextColor(context.getResources().getColor(R.color.colorAccent));\n        return view;\n    }\n    @WXComponentProp(name="showmsg")\n    public void elevation(String elevation) {\n        Log.e("132","nihao");\n        view.setText(elevation);\n    }\n}\n')])])]),n("h4",{attrs:{id:"adapter调用方式"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#adapter调用方式"}},[e._v("#")]),e._v(" Adapter调用方式")]),e._v(" "),n("p",[e._v("Weex 对一些基础功能实现了统一的接口，可实现这些接口来定制自己的业务。例如：图片加载，网络请求，存储管理等。图片加载是一个我们必须使用而weex没有实现的adapter，因此开发weex项目首先要实现对图片加载adapter的配置。")])])}),[],!1,null,null,null);t.default=a.exports}}]);