<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Flutter 面试题</title>
    <meta name="description" content="">
    <meta name="generator" content="VuePress 1.3.1">
    
    
    <link rel="preload" href="/assets/css/0.styles.0bb10e40.css" as="style"><link rel="preload" href="/assets/js/app.b8c9f267.js" as="script"><link rel="preload" href="/assets/js/2.5effd679.js" as="script"><link rel="preload" href="/assets/js/16.cd77e345.js" as="script"><link rel="prefetch" href="/assets/js/10.1e9d6dd9.js"><link rel="prefetch" href="/assets/js/11.36899433.js"><link rel="prefetch" href="/assets/js/12.7b375376.js"><link rel="prefetch" href="/assets/js/13.ca272700.js"><link rel="prefetch" href="/assets/js/14.62f85eb1.js"><link rel="prefetch" href="/assets/js/15.254f14ec.js"><link rel="prefetch" href="/assets/js/17.37843c59.js"><link rel="prefetch" href="/assets/js/18.ff049040.js"><link rel="prefetch" href="/assets/js/19.8b84c72e.js"><link rel="prefetch" href="/assets/js/20.c4e0cf47.js"><link rel="prefetch" href="/assets/js/21.5ca97ceb.js"><link rel="prefetch" href="/assets/js/22.1c3d3481.js"><link rel="prefetch" href="/assets/js/23.fe8a6329.js"><link rel="prefetch" href="/assets/js/24.6e50e452.js"><link rel="prefetch" href="/assets/js/25.4e3061bc.js"><link rel="prefetch" href="/assets/js/26.99d8657b.js"><link rel="prefetch" href="/assets/js/27.a658b46b.js"><link rel="prefetch" href="/assets/js/28.3a81a88b.js"><link rel="prefetch" href="/assets/js/29.7731a3d8.js"><link rel="prefetch" href="/assets/js/3.b60c999d.js"><link rel="prefetch" href="/assets/js/30.5e4771dc.js"><link rel="prefetch" href="/assets/js/31.8b7a30d8.js"><link rel="prefetch" href="/assets/js/32.01da18cd.js"><link rel="prefetch" href="/assets/js/33.db213850.js"><link rel="prefetch" href="/assets/js/34.80b14b0d.js"><link rel="prefetch" href="/assets/js/35.832af720.js"><link rel="prefetch" href="/assets/js/36.af7bb98e.js"><link rel="prefetch" href="/assets/js/37.d454caa4.js"><link rel="prefetch" href="/assets/js/38.480b5662.js"><link rel="prefetch" href="/assets/js/4.cd2082ce.js"><link rel="prefetch" href="/assets/js/5.90db7dea.js"><link rel="prefetch" href="/assets/js/6.0e3d16be.js"><link rel="prefetch" href="/assets/js/7.31ff4035.js"><link rel="prefetch" href="/assets/js/8.ef9b5fc6.js"><link rel="prefetch" href="/assets/js/9.be78d7b3.js">
    <link rel="stylesheet" href="/assets/css/0.styles.0bb10e40.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container no-sidebar"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <!----></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><!---->  <!----> </aside> <main class="page"> <div class="theme-default-content content__default"><h3 id="flutter-面试题"><a href="#flutter-面试题" class="header-anchor">#</a> Flutter 面试题</h3> <h4 id="_1-flutter-是什么？"><a href="#_1-flutter-是什么？" class="header-anchor">#</a> 1. Flutter 是什么？</h4> <p>Flutter是谷歌的移动UI框架，可以快速在iOS和Android上构建高质量的原生用户界面。 Flutter可以与现有的代码一起工作。在全世界，Flutter正在被越来越多的开发者和组织使用，并且Flutter是完全免费、开源的。</p> <h4 id="_2-flutter-特性有哪些？"><a href="#_2-flutter-特性有哪些？" class="header-anchor">#</a> 2. Flutter 特性有哪些？</h4> <p>快速开发（毫秒级热重载）
绚丽UI（内建漂亮的质感设计Material Design和Cupertino Widget和丰富平滑的动画效果和平台感知）
响应式(Reactive，用强大而灵活的API解决2D、动画、手势、效果等难题)
原生访问功能
堪比原生性能</p> <h4 id="_3-flutter-和-dart的关系是什么？"><a href="#_3-flutter-和-dart的关系是什么？" class="header-anchor">#</a> 3. Flutter 和 Dart的关系是什么？</h4> <p>Flutter是一个使用Dart语言开发的跨平台移动UI框架，通过自建绘制引擎，能高性能、高保真地进行移动开发。Dart囊括了多数编程语言的优点，它更符合Flutter构建界面的方式。</p> <h4 id="_4-dart-语言的特性？"><a href="#_4-dart-语言的特性？" class="header-anchor">#</a> 4. Dart 语言的特性？</h4> <ul><li>Productive（生产力高，Dart的语法清晰明了，工具简单但功能强大）</li> <li>Fast（执行速度快，Dart提供提前优化编译，以在移动设备和Web上获得可预测的高性能和快速启动。）</li> <li>Portable（易于移植，Dart可编译成ARM和X86代码，这样Dart移动应用程序可以在iOS、Android和其他地方运行）</li> <li>Approachable（容易上手，充分吸收了高级语言特性，如果你已经知道C++，C语言，或者Java，你可以在短短几天内用Dart来开发）</li> <li>Reactive（响应式编程）</li></ul> <h4 id="_5-dart的一些重要概念？"><a href="#_5-dart的一些重要概念？" class="header-anchor">#</a> 5. Dart的一些重要概念？</h4> <ul><li>在Dart中，一切都是对象，所有的对象都是继承自Object</li> <li>Dart是强类型语言，但可以用var或 dynamic来声明一个变量，Dart会自动推断其数据类型,dynamic类似c#</li> <li>没有赋初值的变量都会有默认值null</li> <li>Dart支持顶层方法，如main方法，可以在方法内部创建方法</li> <li>Dart支持顶层变量，也支持类变量或对象变量</li> <li>Dart没有public protected private等关键字，如果某个变量以下划线（_）开头，代表这个变量在库中是私有的</li></ul> <h4 id="_6-dart是值传递还是引用传递？"><a href="#_6-dart是值传递还是引用传递？" class="header-anchor">#</a> 6. dart是值传递还是引用传递？</h4> <p>dart是引用传递的。</p> <h4 id="_7-widget-和-element-和-renderobject-之间的关系？"><a href="#_7-widget-和-element-和-renderobject-之间的关系？" class="header-anchor">#</a> 7. Widget 和 element 和 RenderObject 之间的关系？</h4> <ul><li><p>Widget是用户界面的一部分,并且是不可变的。</p></li> <li><p>Element是在树中特定位置Widget的实例。</p></li> <li><p>RenderObject是渲染树中的一个对象，它的层次结构是渲染库的核心。</p></li> <li><p>Widget会被inflate（填充）到Element，并由Element管理底层渲染树。Widget并不会直接管理状态及渲染,而是通过State这个对象来管理状态。Flutter创建Element的可见树，相对于Widget来说，是可变的，通常界面开发中，我们不用直接操作Element,而是由框架层实现内部逻辑。就如一个UI视图树中，可能包含有多个TextWidget(Widget被使用多次)，但是放在内部视图树的视角，这些TextWidget都是填充到一个个独立的Element中。Element会持有renderObject和widget的实例。记住，Widget 只是一个配置，RenderObject 负责管理布局、绘制等操作。</p></li> <li><p>在第一次创建 Widget 的时候，会对应创建一个 Element， 然后将该元素插入树中。如果之后 Widget 发生了变化，则将其与旧的 Widget 进行比较，并且相应地更新 Element。重要的是，Element 不会被重建，只是更新而已。</p></li></ul> <h4 id="_8-mixin-extends-implement-之间的关系"><a href="#_8-mixin-extends-implement-之间的关系" class="header-anchor">#</a> 8. mixin extends implement 之间的关系?</h4> <p>继承（关键字 extends）、混入 mixins （关键字 with）、接口实现（关键字 implements）。这三者可以同时存在，前后顺序是extends -&gt; mixins -&gt; implements。
Flutter中的继承是单继承，子类重写超类的方法要用@Override，子类调用超类的方法要用super。
在Flutter中，Mixins是一种在多个类层次结构中复用类代码的方法。mixins的对象是类，mixins绝不是继承，也不是接口，而是一种全新的特性，可以mixins多个类，mixins的使用需要满足一定条件。</p> <h4 id="_9-使用mixins的条件是什么？"><a href="#_9-使用mixins的条件是什么？" class="header-anchor">#</a> 9. 使用mixins的条件是什么？</h4> <p>因为mixins使用的条件，随着Dart版本一直在变，这里讲的是Dart2.1中使用mixins的条件：
mixins类只能继承自object
mixins类不能有构造函数
一个类可以mixins多个mixins类
可以mixins多个类，不破坏Flutter的单继承</p> <h4 id="_10-mixin-怎么指定异常类型？"><a href="#_10-mixin-怎么指定异常类型？" class="header-anchor">#</a> 10. mixin 怎么指定异常类型？</h4> <p>on关键字可用于指定异常类型。 on只能用于被mixins标记的类，例如mixins X on A，意思是要mixins X的话，得先接口实现或者继承A。这里A可以是类，也可以是接口，但是在mixins的时候用法有区别.
on 一个类：</p> <p>复制代码</p> <div class="language- extra-class"><pre class="language-text"><code>class A {
  void a(){
    print(&quot;a&quot;);
  }
}


mixin X on A{
  void x(){
    print(&quot;x&quot;);
  }
}


class mixinsX extends A with X{
}
</code></pre></div><p>on 的是一个接口： 得首先实现这个接口，然后再用mix</p> <p>复制代码</p> <div class="language- extra-class"><pre class="language-text"><code>class A {
  void a(){
    print(&quot;a&quot;);
  }
}

mixin X on A{
  void x(){
    print(&quot;x&quot;);
  }
}

class implA implements A{
  @override
  void a() {}
}

class mixinsX2 extends implA with X{
}
</code></pre></div><h4 id="_11-flutter-main-future-mirotask-的执行顺序"><a href="#_11-flutter-main-future-mirotask-的执行顺序" class="header-anchor">#</a> 11. Flutter main future mirotask 的执行顺序?</h4> <p>普通代码都是同步执行的，结束后会开始检查microtask中是否有任务，若有则执行，执行完继续检查microtask，直到microtask列队为空。最后会去执行event队列（future）。</p> <h4 id="_12-future和isolate有什么区别？"><a href="#_12-future和isolate有什么区别？" class="header-anchor">#</a> 12. Future和Isolate有什么区别？</h4> <p>future是异步编程，调用本身立即返回，并在稍后的某个时候执行完成时再获得返回结果。在普通代码中可以使用await 等待一个异步调用结束。</p> <p>isolate是并发编程，Dartm有并发时的共享状态，所有Dart代码都在isolate中运行，包括最初的main()。每个isolate都有它自己的堆内存，意味着其中所有内存数据，包括全局数据，都仅对该isolate可见，它们之间的通信只能通过传递消息的机制完成，消息则通过端口(port)收发。isolate只是一个概念，具体取决于如何实现，比如在Dart VM中一个isolate可能会是一个线程，在Web中可能会是一个Web Worker。</p> <h4 id="_13-stream-与-future是什么关系？"><a href="#_13-stream-与-future是什么关系？" class="header-anchor">#</a> 13. Stream 与 Future是什么关系？</h4> <p>Stream 和 Future 是 Dart 异步处理的核心 API。Future 表示稍后获得的一个数据，所有异步的操作的返回值都用 Future 来表示。但是 Future 只能表示一次异步获得的数据。而 Stream 表示多次异步获得的数据。比如界面上的按钮可能会被用户点击多次，所以按钮上的点击事件（onClick）就是一个 Stream 。简单地说，Future将返回一个值，而Stream将返回多次值。Dart 中统一使用 Stream 处理异步事件流。Stream 和一般的集合类似，都是一组数据，只不过一个是异步推送，一个是同步拉取。</p> <h4 id="_14-stream-两种订阅模式？"><a href="#_14-stream-两种订阅模式？" class="header-anchor">#</a> 14. Stream 两种订阅模式？</h4> <ul><li>Stream有两种订阅模式：单订阅(single) 和 多订阅（broadcast）。单订阅就是只能有一个订阅者，而广播是可以有多个订阅者。这就有点类似于消息服务（Message Service）的处理模式。单订阅类似于点对点，在订阅者出现之前会持有数据，在订阅者出现之后就才转交给它。而广播类似于发布订阅模式，可以同时有多个订阅者，当有数据时就会传递给所有的订阅者，而不管当前是否已有订阅者存在。</li> <li>Stream 默认处于单订阅模式，所以同一个 stream 上的 listen 和其它大多数方法只能调用一次，调用第二次就会报错。但 Stream 可以通过 transform() 方法（返回另一个 Stream）进行连续调用。通过 Stream.asBroadcastStream() 可以将一个单订阅模式的 Stream 转换成一个多订阅模式的 Stream，isBroadcast 属性可以判断当前 Stream 所处的模式。</li></ul> <h4 id="_15-await-for-如何使用"><a href="#_15-await-for-如何使用" class="header-anchor">#</a> 15. await for 如何使用?</h4> <p>await for是不断获取stream流中的数据，然后执行循环体中的操作。它一般用在直到stream什么时候完成，并且必须等待传递完成之后才能使用，不然就会一直阻塞。</p> <div class="language- extra-class"><pre class="language-text"><code>Stream&lt;String&gt; stream = new Stream&lt;String&gt;.fromIterable(['不开心', '面试', '没', '过']);

main() async{
  print('上午被开水烫了脚');
  await for(String s in stream){
    print(s);
  }
  print('晚上还没吃饭');
}
</code></pre></div><h4 id="_16-flutter中的widget、state、context-的核心概念？是为了解决什么问题？"><a href="#_16-flutter中的widget、state、context-的核心概念？是为了解决什么问题？" class="header-anchor">#</a> 16. Flutter中的Widget、State、Context 的核心概念？是为了解决什么问题？</h4> <ul><li><p>Widget: 在Flutter中，几乎所有东西都是Widget。将一个Widget想象为一个可视化的组件（或与应用可视化方面交互的组件），当你需要构建与布局直接或间接相关的任何内容时，你正在使用Widget。</p></li> <li><p>Widget树: Widget以树结构进行组织。包含其他Widget的widget被称为父Widget(或widget容器)。包含在父widget中的widget被称为子Widget。</p></li> <li><p>Context: 仅仅是已创建的所有Widget树结构中的某个Widget的位置引用。简而言之，将context作为widget树的一部分，其中context所对应的widget被添加到此树中。一个context只从属于一个widget，它和widget一样是链接在一起的，并且会形成一个context树。</p></li> <li><p>State: 定义了StatefulWidget实例的行为，它包含了用于”交互/干预“Widget信息的行为和布局。应用于State的任何更改都会强制重建Widget。</p></li></ul> <p>这些状态的引入，主要是为了解决多个部件之间的交互和部件自身状态的维护。</p> <h4 id="_17-widget的两种类型是什么？"><a href="#_17-widget的两种类型是什么？" class="header-anchor">#</a> 17. Widget的两种类型是什么？</h4> <ul><li><p>StatelessWidget: 一旦创建就不关心任何变化，在下次构建之前都不会改变。它们除了依赖于自身的配置信息（在父节点构建时提供）外不再依赖于任何其他信息。比如典型的Text、Row、Column、Container等，都是StatelessWidget。它的生命周期相当简单：初始化、通过build()渲染。</p></li> <li><p>StatefulWidget: 在生命周期内，该类Widget所持有的数据可能会发生变化，这样的数据被称为State，这些拥有动态内部数据的Widget被称为StatefulWidget。比如复选框、Button等。State会与Context相关联，并且此关联是永久性的，State对象将永远不会改变其Context，即使可以在树结构周围移动，也仍将与该context相关联。当state与context关联时，state被视为已挂载。StatefulWidget由两部分组成，在初始化时必须要在createState()时初始化一个与之相关的State对象。</p></li></ul> <h4 id="_18-state-对象的初始化流程？"><a href="#_18-state-对象的初始化流程？" class="header-anchor">#</a> 18. State 对象的初始化流程？</h4> <ul><li>initState() : 一旦State对象被创建，initState方法是第一个（构造函数之后）被调用的方法。可通过重写来执行额外的初始化，如初始化动画、控制器等。重写该方法时，应该首先调用super.initState()。在initState中，无法真正使用context，因为框架还没有完全将其与state关联。initState在该State对象的生命周期内将不会再次调用。</li> <li>didChangeDependencies(): 这是第二个被调用的方法。在这一阶段，context已经可用。如果你的Widget链接到了一个InheritedWidget并且/或者你需要初始化一些listeners（基于context），通常会重写该方法。</li> <li>build(BuildContext context): 此方法在didChangeDependencies()、didUpdateWidget()之后被调用。每次State对象更新（或当InheritedWidget有新的通知时）都会调用该方法！我们一般都在build中来编写真正的功能代码。为了强制重建，可以在需要的时候调用setState((){...})方法。</li> <li>dispose(): 此方法在Widget被废弃时调用。可重写该方法来执行一些清理操作（如解除listeners），并在此之后立即调用super.dispose()。</li></ul> <h4 id="_19-widget-唯一标识key有那几种？"><a href="#_19-widget-唯一标识key有那几种？" class="header-anchor">#</a> 19. Widget 唯一标识Key有那几种？</h4> <p>在flutter中，每个widget都是被唯一标识的。这个唯一标识在build或rendering阶段由框架定义。该标识对应于可选的Key参数，如果省略，Flutter将会自动生成一个。</p> <p>在flutter中，主要有4种类型的Key：GlobalKey（确保生成的Key在整个应用中唯一，是很昂贵的，允许element在树周围移动或变更父节点而不会丢失状态）、LocalKey、UniqueKey、ObjectKey。</p> <h4 id="_20-什么是navigator-materialapp做了什么？"><a href="#_20-什么是navigator-materialapp做了什么？" class="header-anchor">#</a> 20. 什么是Navigator? MaterialApp做了什么？</h4> <p>Navigator是在Flutter中负责管理维护页面堆栈的导航器。MaterialApp在需要的时候，会自动为我们创建Navigator。Navigator.of(context)，会使用context来向上遍历Element树，找到MaterialApp提供的_NavigatorState再调用其push/pop方法完成导航操作。</p></div> <footer class="page-edit"><!----> <!----></footer> <!----> </main></div><div class="global-ui"></div></div>
    <script src="/assets/js/app.b8c9f267.js" defer></script><script src="/assets/js/2.5effd679.js" defer></script><script src="/assets/js/16.cd77e345.js" defer></script>
  </body>
</html>
